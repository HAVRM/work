基本的に次の書き方である。またコメントは#から書き出す。一行のみ

#blockquote(){
#highlight(c){
ターゲット名: 依存ファイル1 依存ファイル2 ..
(タブで開ける)コマンド行1
(タブで開ける)コマンド行2
              ..
}
}

ターゲット名とは生成したいファイル、依存ファイルとはそれを作るのに必要なファイル(includeしているのは対象外っぽい)。コマンド行とは端末で書くようなもの。コマンド行の途中で改行してはいけない。次のファイル
・hello.c
・sub.c
をコンパイルしてhelloというファイルを作りたいときは次のように書く。

#blockquote(){
#highlight(c){
hello: hello.c sub.c
(タブで開ける)gcc -Wall -O2 -o hello hello.c sub.c
}
}

これにさらにmake内で使えるマクロ(マクロ名= で定義、$(マクロ名)で使用)を使うと

#blockquote(){
#highlight(c){
CC=gcc
PROG=hello.c sub.c

hello: $(PROG)
(タブで開ける)$(CC) -Wall -O2 -o $@ $<
}
}

のように書ける。決まっているマクロ名のうちよく使うであろうものを下に書く

・CC(基準値=cc):Cコンパイラ
・CXX(基準値=g++):C++コンパイラ
・RM(基準値=rm -f):ファイルの削除

また次のものを内部マクロと呼び、書かれた内容によって変わる

・$@:その行のターゲと名を呼び出す
・$<:その行の依存ファイルを呼び出す

さらにサフィックスルールというコンパイル次の決まり事を指定することで簡単に記述できる。

#blockquote(){
#highlight(c){
CC=gcc
PROG=hello.c sub.c

.c.o
(タブで開ける)$(CC) -Wall -O2 -o $@ $<

hello: $(PROG)
}
}

サフィックスルールは上の.c.oの部分で
「.oファイルは.cから作ることができ、その時の動作はこうである」
と記述できる。

またインクルードするプログラムのうちいくつかが変わったとき、これだけではコンパイル時に最新であると言って更新されないことがある。これを防ぐ方法はいろいろあるが、手っ取り早いのはコンパイルによって生成されたファイルを一度削除することである。この時makeと打つだけでなく、オプション的に書き加えることでコンパイルする以外の動作をさせることができる。これをphonyターゲットと呼び、ターゲット名と混同を防ぐため次のように書く。次のはmake cleanとコマンドを打つことでそのファイルの中にある一時ファイル(*~)、実行ファイル(.o)を消すものである。

#blockquote(){
#highlight(c){
CC=gcc
PROG=hello.c sub.c

.c.o
(タブで開ける)$(CC) -Wall -O2 -o $@ $<

hello: $(PROG)

.PHONY: clean
clean:
(タブで開ける)$(RM) *~ *.o
}
}

.PHONYでphonyターゲットを作成している。ここで標準で定義されているマクロRMを用いて楽にしている。

最後に上のプログラムで毎回cleanしたあとにコンパイルしたいや、いろんな動作を一度にmakeとうつだけでやりたいという時はallというphonyターゲットでまとめれば良い。最終的に次のようになる

#blockquote(){
#highlight(c){
CC=gcc
PROG=hello.c sub.c

.PHONY: all
all: clean hello

.c.o
(タブで開ける)$(CC) -Wall -O2 -o $@ $<

hello: $(PROG)

.PHONY: clean
clean:
(タブで開ける)$(RM) *~ *.o
}
}

また端末でmakeと書くだけで一番上のターゲットまたはphonyターゲットを実行する(未確認)ためその時になかったファイルはそのMakefile内に記述またはサフィックスルールがもともと定義されているものはそれにしたがって作成される。